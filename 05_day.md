# 5-1 起動情報の受け取り
実は，bootpack.cにVRAMの番地や画面サイズを直に描いておくのはよろしくないです．
なんでかというと，これらの値は画面モードによって変わってしまいますし，画面モードの設定はasmhead.nasでやっていたのです．
なので，これらの値はasmhead.nasで画面モードを設定する時にどこかにメモしておいて，それを取り出して使うべきです．
で，これらの値は[0xff0]以降にメモしてあるのです(詳しくはasmhead.nasの最初の方を見て下さい)．

あと，背景を描画する部分は```init_screen```関数になりました．

# 5-2 構造体を使ってみる
asmhead.nasでメモした起動情報を一つ一つbinfo_なんとかというポインタ変数を作って番地を指定して読み出すのは面倒なので，構造体というものを使ってみます．

構造体というのは，新しい型のようなものを作ることができるC言語の機能です．
```
struct BOOTINFO {
	char cyls, leds, vmode, reserve;
	short scrnx, scrny;
	char* vram;
};
```
というようにすると，```BOOTINFO```という名前の構造体を定義できます．
そして，この構造体は```char```型の変数```cyls, leds, vmode, reserve```，
```short```型の変数```scrnx, scrny```，
```char*```型の変数```vram```を内部に持ちます．
このような構造体内部の変数のことをメンバ(変数)といいます．

この構造体を使うには，```struct BOOTINFO binfo;```のようにすると，```BOOTINFO```構造体の変数```binfo```ができます．
```struct BOOTINFO```が型のようなものというわけですね．

このようにして作った構造体は，普通の変数と同じように値を読んだり書いたりすることができます．
ただし，値の読み書きができるのは構造体自体ではなく構造体のメンバ変数です．
構造体変数からメンバ変数にアクセスするには```.```という演算子を使います．

まとめると，
```
struct BOOTINFO binfo;
binfo.scrnx = 300;
binfo.scrny = 200;
binfo.vram = 0xa0000;
```
というようなことができるわけです．
こうのように，構造体自体も，構造体のメンバ変数も普通の変数のように扱うことができます．

また，構造体変数は普通の変数と同じように使えるので，普通の変数と同じようにポインタも使えます．
```
struct BOOTINFO *binfo;
```
とすると，```BOOTINFO```構造体のポインタ変数(番地変数)```binfo```を作ることができます．

そして，asmhead.nasで起動情報は[0xff0]にメモしておいたのでした．
なので，あとはこのポインタ変数```binfo```にアドレスを設定してやればいいわけです．
```
binfo = (struct BOOTINFO *) 0x0ff0;
```
さて，構造体のポインタ変数にアドレスを設定したので，あとはここからメンバ変数の値を読み出して使っていけばOKですね．
ポインタ変数からそのアドレスが指す先の値を使うには，ポインタ変数に```*```を付ければよいのでした．
なので，```*binfo```が```BOOTINFO```構造体として扱えるはずです．
そして，構造体変数からメンバにアクセスするには```.```演算子を使うのでした．
よって，```(*binfo).scrnx```のようにすると，[0xff0]以降に並んでいる起動情報を```BOOTINFO```構造体として扱って，その中のscrnxメンバにアクセスできるわけですね．

で，こうすると```binfo_なんたら```とかいう変数をたくさん作って一々それにアドレスを設定して．．．とかいうことをやらずに済むわけです．
構造体バンザイですね．

# 5-3 矢印表記を使ってみる
```(*binfo).scrnx```とか毎回書くのは面倒なんですが，こういうことは結構書く機械があるんですね．
なのでこれにも省略表現があります．
```binfo->scrnx```，みたいなかんじです．
これは楽ですね．
目にも優しいです．

# 5-4 とにかく文字を出したい
そういえば16bitモードの時はBIOSにお願いしたら簡単に文字を出せたのですが，32bitモードとなった今はそんなことはできない(BIOSは16bit用に書かれているため，32bitモードでは使えない)のです．
「BIOSよさらば！16bitモード堂々退場す」
というかんじですね(?)．

さて，BIOSが使えないので，文字を出そうと思ったら自分でどうにかしてやらなければいけません．
絵を描くにはVRAMにいいかんじに書き込めばいいのです．つまり，

```
00000000	= 0x00
00011000	= 0x18
00011000	= 0x18
00011000	= 0x18
00011000	= 0x18
00100100	= 0x24
00100100	= 0x24
00100100	= 0x24
00100100	= 0x24
01111110	= 0x7e
01000010	= 0x42
01000010	= 0x42
01000010	= 0x42
11100111	= 0xe7
00000000	= 0x00
00000000	= 0x00
```
みたいなことをVRAMに書き込んでやれば，"A"っぽいものが描画されるはずです．
こういう文字の形のデータをフォントといいます．

というわけで，このフォントデータをどこかに置いておいて，このデータにおける1に対応する座標(に対応するVRAMの番地)に色を設定してやれば，'A'という文字が描画できるはずです．あとはやるだけですね．

# 5-5 フォントを増やしたい
'A'のフォントを用意するだけで一苦労でしたが，すべての文字に対して一々こんなことをやっていたらOS自作ではなくフォント自作になってしまいます．
ということでOSASKのフォント(自由に流用が認められています)を使います．
これはどういうものかというと，hankaku.txtというファイルにフォントデータが人間にとって分かりやすい形式(0,1ではなく'.','*')で入っています．
ただ，これをそのままC言語から使うことはできないので，まずmakefontというツールでバイナリ(hankaku.bin)に変換します．
そして，これをbin2objというツールでオブジェクトファイルに変換します．
これにより，このときコマンドラインで指定した"_hankaku"という名前で，フォントデータをつらつらとDBしたものがC言語から使える形になります．
これをC言語から使うには，```extern char hankaku[16 * 256];```のようにしてやればよいです．

で，ここから特定の文字のフォントデータを取り出す方法ですが，```char hankaku[16 * 256]```は文字コード0x00から0xffまでの文字のフォントデータが延々と並んでいるので，文字コードnの文字のフォントデータの先頭は```hankaku + n * 16```番地になります．
あとはこれを先程と同じように```putfont8```関数に渡してやれば，色々な文字を表示することができますね．

# 5-6 文字列を書きたい
文字列書きたいですよね！！！
せっかく色々な文字が書けるようになったので，"Hello, World!"とか"Haribote OS"とか書いてみたいです．
でも，今それをやろうと思ったら文字の個数分```putfont8```関数を呼び出すコードを書かないといけません．
それはちょっとおもしろくないので，文字列を渡すと文字数分```putfont8```関数を呼び出す関数を作ってしまえば楽になります．
C言語においては文字列は0x00で終わることが決まっているので，順番に文字を見ていって，0x00が来たら終わりにすればいいですね．
というわけでできたのが```putfont8_asc```関数です．
ascというのはASCIIのことで，ASCIIは文字コードの名前です．
