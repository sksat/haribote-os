# 3-1 さあ本当のIPLを作ろう
まず，名前がhelloosからはりぼてOSに変わりましたのでよろしくお願いしますはい．
今までのIPLはなんのプログラムもロードしていなかったので，します．

とりあえずプログラムのロードということでブートセクタの次の１セクタ(512バイト)を読み込んでみましょう．
どうやってプログラムをロードするのかというと，文字出力の時と同じく[BIOSファンクション](http://oswiki.osask.jp/?(AT)BIOS )を使います．

フロッピーディスクを使っているので，ドライブは懐かしのAドライブ，読み込みなのでAH=0x02，シリンダ，ヘッドはそれぞれ0，セクタは2です．
読み込み先のメモリアドレスであるバッファアドレスはES:BXなので，```ES*16+BX```が実際のアドレスになります．
EBXとかの32bitレジスタが使えれば話は速いのですが，この仕組みは32bitレジスタなんてものが存在しなかった時代に出来たものなので，このようにして1MBまでのアドレスを指定します．
このようにアドレスの(広域な)指定に使うESのようなレジスタのことをセグメントレジスタといいます．
実は普通にMOVとかの命令を使っているときにもセグメントレジスタというのは使われていて，何も指定していないときはDSが使われています．だからDSにはまっさきに0x00を入れていたんですね．
あと，実行する命令のアドレスを指すプログラムカウンタであるIPも，それだけでは実際のアドレスではなく，CS:IPが実際のアドレスだったりします．
ここらへんの話は，本や[この記事](http://softwaretechnique.jp/OS_Development/bootloader7.html)などが分かりやすいでしょう．

# 3-2 エラーになったらやり直そう
JNC:
	jump if not carry
	carryはキャリーフラグのこと．
JAE:
	jump if above or equal
	大きいかもしくは等しければジャンプ

AH=0x00,DL=0x00でのINT 0x13は「(ディスクの)システムのリセット」

# 3-3 18セクタまで読んでみる
JBE:
	jump if below or equal
	小さいかもしくは等しければジャンプ

次のセクタを読むのに必要なことは，CL(=セクタ番号)を1足すことと，ESを512/16増やすこと．
まあバッファアドレスはES*16+BXなので，BX+=512の方がラクですがそれは本の都合です．
あと，これって実はループにする必要はなくて，ALを17にしておけば「処理するセクタ数」が17，つまりセクタ2〜18が読み込めていいじゃないか，というかんじなんですが，(おそらくフロッピーの場合は)複数のトラックにまたがっていたり，64KB境界を超えたりするとダメみたいなのでループになっています(これからどんどん読み込んでいくので)．

# 3-4 10シリンダ分を読んでみる
JB:
	jump if below
	小さければジャンプ

EQUはnaskの命令で，定数が宣言できる(Cなどにおけるdefineのようなもの)．
CYLSは読み込むシリンダ数．
前回書いた注意があるので，ちゃんと1セクタずつ読み込んでいます．
